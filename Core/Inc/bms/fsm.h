/******************************************************************************
Finite State Machine
Project: cellboard_fsm
Description: Main cellboard FSM that handles all the operations of the BMS

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.4
Generation date: 2024-07-30 17:08:49 +0200
Generated from: fsm.dot
The finite state machine has:
  6 states
  9 transition functions
Functions and types have been generated with prefix "fsm_"
******************************************************************************/

#ifndef FSM_H
#define FSM_H
#include <stdlib.h>
#include <stdbool.h>

/*** USER CODE BEGIN MACROS ***/
#include <stddef.h>

#include "bms_network.h"

/** @brief Timeouts for the discharge and cooldown watchdogs in ms */
#define FSM_DISCHARGE_TIMEOUT ((milliseconds_t)(2000U))
#define FSM_COOLDOWN_TIMEOUT ((milliseconds_t)(18000U))

/**
 * @brief Definition of the possible events types
 *
 * @details The FSM_EVENT_TYPE_IGNORED should only be used for initialization purposes
 * and it is not counted as part of the other events
 *
 * @details
 *     - FSM_EVENT_TYPE_FLASH_REQUEST the request for the start of a flash procedure
 *     - FSM_EVENT_TYPE_BALANCING_START the request to start the balancing procedure
 *     - FSM_EVENT_TYPE_BALANCING_STOP the request to stop the balancing procedure
 *     - FSM_EVENT_TYPE_DISCHARGE_REQUEST the request to start the discharge procedure
 *     - FSM_EVENT_TYPE_COOLDOWN_REQUEST the request to start the cooldown procedure
 *     - FSM_EVENT_TYPE_IGNORED event that should be ignored
 */
typedef enum {
    FSM_EVENT_TYPE_FLASH_REQUEST,
    FSM_EVENT_TYPE_BALANCING_START,
    FSM_EVENT_TYPE_BALANCING_STOP,
    FSM_EVENT_TYPE_DISCHARGE_REQUEST,
    FSM_EVENT_TYPE_COOLDOWN_REQUEST,
    FSM_EVENT_TYPE_COUNT,
    FSM_EVENT_TYPE_IGNORED
} FsmEventType;
/*** USER CODE END MACROS ***/

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
/*** USER STATE DATA TYPE BEGIN ***/
typedef void fsm_state_data_t;
/*** USER STATE DATA TYPE END ***/
// Event data object
// By default the struct is empty; put the data of the event inside
// the structure if you need or leave it empty
typedef struct {
  
  /*** USER CODE BEGIN EVENT_DATA ***/
  FsmEventType type;
  /*** USER CODE END EVENT_DATA ***/

} fsm_event_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  FSM_STATE_INIT = 0,  
  FSM_STATE_IDLE,  
  FSM_STATE_FATAL,  
  FSM_STATE_FLASH,  
  FSM_STATE_DISCHARGE,  
  FSM_STATE_COOLDOWN,  
  FSM_NUM_STATES,
  FSM_NO_CHANGE
} fsm_state_t;

// State human-readable names
extern const char *fsm_state_names[];

// State function and state transition prototypes
typedef fsm_state_t fsm_state_func_t(fsm_state_data_t *data);
typedef void transition_func_t(fsm_state_data_t *data);

/*** USER CODE BEGIN TYPES ***/

/*** USER CODE END TYPES ***/

// Functions to check and trigger an event
bool fsm_is_event_triggered();
void fsm_event_trigger(fsm_event_data_t *event);

// State functions

// Function to be executed in state init
// valid return states: FSM_STATE_IDLE, FSM_STATE_FATAL
fsm_state_t fsm_do_init(fsm_state_data_t *data);

// Function to be executed in state idle
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_DISCHARGE, FSM_STATE_FATAL
fsm_state_t fsm_do_idle(fsm_state_data_t *data);

// Function to be executed in state fatal
// valid return states: FSM_NO_CHANGE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_fatal(fsm_state_data_t *data);

// Function to be executed in state flash
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_flash(fsm_state_data_t *data);

// Function to be executed in state discharge
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_DISCHARGE, FSM_STATE_COOLDOWN, FSM_STATE_FATAL
fsm_state_t fsm_do_discharge(fsm_state_data_t *data);

// Function to be executed in state cooldown
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_DISCHARGE, FSM_STATE_COOLDOWN, FSM_STATE_FATAL
fsm_state_t fsm_do_cooldown(fsm_state_data_t *data);


// List of state functions
extern fsm_state_func_t *const fsm_state_table[FSM_NUM_STATES];


// Transition functions
void fsm_start(fsm_state_data_t *data);
void fsm_handle_init_error(fsm_state_data_t *data);
void fsm_start_flash_procedure(fsm_state_data_t *data);
void fsm_start_discharge(fsm_state_data_t *data);
void fsm_handle_fatal_error(fsm_state_data_t *data);
void fsm_stop_flash_procedure(fsm_state_data_t *data);
void fsm_stop_discharge(fsm_state_data_t *data);
void fsm_start_cooldown(fsm_state_data_t *data);
void fsm_restart_discharge(fsm_state_data_t *data);

// Table of transition functions
extern transition_func_t *const fsm_transition_table[FSM_NUM_STATES][FSM_NUM_STATES];

// state manager
fsm_state_t fsm_run_state(fsm_state_t cur_state, fsm_state_data_t *data);

/*** USER CODE BEGIN FUNCTIONS ***/
/**
 * @brief Get the current status of the FSM
 *
 * @return fsm_state_t The FSM status
 */
fsm_state_t fsm_get_status(void);

/**
 * @brief Get a pointer to the CAN payload structure of the FSM status
 *
 * @param byte_size[out] A pointer where the size of the payload in bytes is stored (can be NULL)
 *
 * @return bms_cellboard_status_converted_t* A pointer to the payload
 */
bms_cellboard_status_converted_t * fsm_get_canlib_payload(size_t * byte_size);
/*** USER CODE END FUNCTIONS ***/

#endif
