/******************************************************************************
Finite State Machine
Project: cellboard_bms_monitor_fsm
Description: Cellboard FSM that handles all the operations of the BMS monitor

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.4
Generation date: 2024-08-27 21:00:28 +0200
Generated from: bms-monitor-fsm.dot
The finite state machine has:
  16 states
  1 transition functions
Functions and types have been generated with prefix "bms_monitor_fsm_"
******************************************************************************/

#include "bms-monitor-fsm.h"

/*** USER CODE BEGIN MACROS ***/
#include <stdint.h>
#include <string.h>

#include "timebase.h"
#include "error.h"
/*** USER CODE END MACROS ***/


// GLOBALS
// State human-readable names
const char *bms_monitor_fsm_state_names[] = {"init", "start_volt_conversion", "poll_volt_status", "volt_comm_error", "read_voltage", "start_temp_conversion", "poll_temp_status", "temp_comm_error", "read_temperature", "start_open_wire_pup_conversion", "poll_open_wire_pup_status", "open_wire_comm_error", "read_open_wire_pup", "start_open_wire_pud_conversion", "poll_open_wire_pud_status", "read_open_wire_pud"};

// List of state functions
bms_monitor_fsm_state_func_t *const bms_monitor_fsm_state_table[BMS_MONITOR_FSM_NUM_STATES] = {
  bms_monitor_fsm_do_init,                           // in state init
  bms_monitor_fsm_do_start_volt_conversion,          // in state start_volt_conversion
  bms_monitor_fsm_do_poll_volt_status,               // in state poll_volt_status
  bms_monitor_fsm_do_volt_comm_error,                // in state volt_comm_error
  bms_monitor_fsm_do_read_voltage,                   // in state read_voltage
  bms_monitor_fsm_do_start_temp_conversion,          // in state start_temp_conversion
  bms_monitor_fsm_do_poll_temp_status,               // in state poll_temp_status
  bms_monitor_fsm_do_temp_comm_error,                // in state temp_comm_error
  bms_monitor_fsm_do_read_temperature,               // in state read_temperature
  bms_monitor_fsm_do_start_open_wire_pup_conversion, // in state start_open_wire_pup_conversion
  bms_monitor_fsm_do_poll_open_wire_pup_status,      // in state poll_open_wire_pup_status
  bms_monitor_fsm_do_open_wire_comm_error,           // in state open_wire_comm_error
  bms_monitor_fsm_do_read_open_wire_pup,             // in state read_open_wire_pup
  bms_monitor_fsm_do_start_open_wire_pud_conversion, // in state start_open_wire_pud_conversion
  bms_monitor_fsm_do_poll_open_wire_pud_status,      // in state poll_open_wire_pud_status
  bms_monitor_fsm_do_read_open_wire_pud,             // in state read_open_wire_pud
};

// Table of transition functions
transition_func_t *const bms_monitor_fsm_transition_table[BMS_MONITOR_FSM_NUM_STATES][BMS_MONITOR_FSM_NUM_STATES] = {
  /* states:                            init                           , start_volt_conversion          , poll_volt_status               , volt_comm_error                , read_voltage                   , start_temp_conversion          , poll_temp_status               , temp_comm_error                , read_temperature               , start_open_wire_pup_conversion , poll_open_wire_pup_status      , open_wire_comm_error           , read_open_wire_pup             , start_open_wire_pud_conversion , poll_open_wire_pud_status      , read_open_wire_pud              */
  /* init                           */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* start_volt_conversion          */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* poll_volt_status               */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* volt_comm_error                */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* read_voltage                   */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* start_temp_conversion          */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* poll_temp_status               */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* temp_comm_error                */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* read_temperature               */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* start_open_wire_pup_conversion */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* poll_open_wire_pup_status      */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* open_wire_comm_error           */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* read_open_wire_pup             */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* start_open_wire_pud_conversion */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* poll_open_wire_pud_status      */ {NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
  /* read_open_wire_pud             */ {NULL                           , bms_monitor_fsm_check_open_wire, NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           , NULL                           }, 
};

// Triggered event
bms_monitor_fsm_event_data_t * bms_monitor_fsm_fired_event = NULL;

/*** USER CODE BEGIN GLOBALS ***/
_STATIC _BmsMonitorFsmHandler hfsm;
/*** USER CODE END GLOBALS ***/


// Function to check if an event has fired
bool bms_monitor_fsm_is_event_triggered() {
    return bms_monitor_fsm_fired_event != NULL;
}

// Function to trigger an event
void bms_monitor_fsm_event_trigger(bms_monitor_fsm_event_data_t *event) {
    if (bms_monitor_fsm_fired_event != NULL)
        return;
    bms_monitor_fsm_fired_event = event ? event : &(bms_monitor_fsm_event_data_t){};
}


/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_init(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_INIT ***/
  memset(&hfsm, 0U, sizeof(hfsm));
  /*** USER CODE END DO_INIT ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_volt_conversion
// valid return states: BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS, BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_volt_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS;
  
  
  /*** USER CODE BEGIN DO_START_VOLT_CONVERSION ***/
  if (bms_manager_start_volt_conversion() == BMS_MANAGER_OK) {
      hfsm.poll_err_count = 0U;
      next_state = BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS;
  }
  else
      next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  /*** USER CODE END DO_START_VOLT_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
    case BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_volt_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS, BMS_MONITOR_FSM_STATE_READ_VOLTAGE, BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_volt_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_VOLT_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_VOLTAGE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT)
              next_state = BMS_MONITOR_FSM_STATE_READ_VOLTAGE;
              // next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
          break;
  }
  /*** USER CODE END DO_POLL_VOLT_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_VOLTAGE:
    case BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state volt_comm_error
// valid return states: BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_volt_comm_error(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_VOLT_COMM_ERROR ***/
  
  /*** USER CODE END DO_VOLT_COMM_ERROR ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_voltage
// valid return states: BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR, BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_voltage(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  
  
  /*** USER CODE BEGIN DO_READ_VOLTAGE ***/
  next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
  if (bms_manager_read_voltages(BMS_MANAGER_VOLTAGE_REGISTER_A) != BMS_MANAGER_OK)
        next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  if (bms_manager_read_voltages(BMS_MANAGER_VOLTAGE_REGISTER_B) != BMS_MANAGER_OK)
        next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  if (bms_manager_read_voltages(BMS_MANAGER_VOLTAGE_REGISTER_C) != BMS_MANAGER_OK)
        next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  if (bms_manager_read_voltages(BMS_MANAGER_VOLTAGE_REGISTER_D) != BMS_MANAGER_OK)
        next_state = BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR;
  /*** USER CODE END DO_READ_VOLTAGE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_VOLT_COMM_ERROR:
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_temp_conversion
// valid return states: BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS, BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_temp_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS;
  
  
  /*** USER CODE BEGIN DO_START_TEMP_CONVERSION ***/
  if (bms_manager_start_temp_conversion() == BMS_MANAGER_OK) {
      hfsm.poll_err_count = 0U;
      next_state = BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS;
  }
  else
      next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR;
  /*** USER CODE END DO_START_TEMP_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
    case BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_temp_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS, BMS_MONITOR_FSM_STATE_READ_TEMPERATURE, BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_temp_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_TEMP_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_TEMPERATURE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT)
              next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR;
          break;
  }
  /*** USER CODE END DO_POLL_TEMP_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_TEMPERATURE:
    case BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state temp_comm_error
// valid return states: BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_temp_comm_error(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_TEMP_COMM_ERROR ***/
  
  /*** USER CODE END DO_TEMP_COMM_ERROR ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_temperature
// valid return states: BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_temperature(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR;
  
  
  /*** USER CODE BEGIN DO_READ_TEMPERATURE ***/
  next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
  if (bms_manager_read_temperatures(BMS_MANAGER_TEMPERATURE_REGISTER_A) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR; 
  if (bms_manager_read_temperatures(BMS_MANAGER_TEMPERATURE_REGISTER_B) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR;
  /*** USER CODE END DO_READ_TEMPERATURE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_TEMP_COMM_ERROR:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_open_wire_pup_conversion
// valid return states: BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_open_wire_pup_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS;
  
  
  /*** USER CODE BEGIN DO_START_OPEN_WIRE_PUP_CONVERSION ***/
  return BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_start_open_wire_conversion(LTC6811_PUP_ACTIVE) == BMS_MANAGER_OK) {
      hfsm.poll_err_count = 0U;
      next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS;
  }
  else
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  /*** USER CODE END DO_START_OPEN_WIRE_PUP_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_open_wire_pup_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_open_wire_pup_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_OPEN_WIRE_PUP_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
          if (++hfsm.open_wire_operations >= BMS_MONITOR_FSM_OPEN_WIRE_PUP_CONVERSION_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP;
          }
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          if (++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
          }
          break;
      default:
          hfsm.open_wire_operations = 0U;
          next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
          break;
  }
  /*** USER CODE END DO_POLL_OPEN_WIRE_PUP_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state open_wire_comm_error
// valid return states: BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_open_wire_comm_error(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_OPEN_WIRE_COMM_ERROR ***/
  
  /*** USER CODE END DO_OPEN_WIRE_COMM_ERROR ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_open_wire_pup
// valid return states: BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_open_wire_pup(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_READ_OPEN_WIRE_PUP ***/
  next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_A, BMS_MANAGER_OPEN_WIRE_OPERATION_PUP) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_B, BMS_MANAGER_OPEN_WIRE_OPERATION_PUP) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_C, BMS_MANAGER_OPEN_WIRE_OPERATION_PUP) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_D, BMS_MANAGER_OPEN_WIRE_OPERATION_PUP) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  /*** USER CODE END DO_READ_OPEN_WIRE_PUP ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_open_wire_pud_conversion
// valid return states: BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_open_wire_pud_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS;
  
  
  /*** USER CODE BEGIN DO_START_OPEN_WIRE_PUD_CONVERSION ***/
  if (bms_manager_start_open_wire_conversion(LTC6811_PUP_INACTIVE) == BMS_MANAGER_OK) {
      hfsm.poll_err_count = 0U;
      next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS;
  }
  else
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  /*** USER CODE END DO_START_OPEN_WIRE_PUD_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_open_wire_pud_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_open_wire_pud_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_OPEN_WIRE_PUD_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION;
          if (++hfsm.open_wire_operations >= BMS_MONITOR_FSM_OPEN_WIRE_PUD_CONVERSION_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD;
          }
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          if (++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
          }
          break;
      default:
          hfsm.open_wire_operations = 0U;
          next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
          break;
  }
  /*** USER CODE END DO_POLL_OPEN_WIRE_PUD_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_open_wire_pud
// valid return states: BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION, BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_open_wire_pud(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
  
  
  /*** USER CODE BEGIN DO_READ_OPEN_WIRE_PUD ***/
  next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_A, BMS_MANAGER_OPEN_WIRE_OPERATION_PUD) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_B, BMS_MANAGER_OPEN_WIRE_OPERATION_PUD) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_C, BMS_MANAGER_OPEN_WIRE_OPERATION_PUD) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  if (bms_manager_read_open_wire_voltages(BMS_MANAGER_VOLTAGE_REGISTER_D, BMS_MANAGER_OPEN_WIRE_OPERATION_PUD) != BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR;
  /*** USER CODE END DO_READ_OPEN_WIRE_PUD ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
    case BMS_MONITOR_FSM_STATE_OPEN_WIRE_COMM_ERROR:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 1 transition:
// 1. from read_open_wire_pud to start_volt_conversion
void bms_monitor_fsm_check_open_wire(bms_monitor_fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN CHECK_OPEN_WIRE ***/
  BmsManagerReturnCode code = bms_manager_check_open_wire(); 
  switch (code) {
      case BMS_MANAGER_OK:
          error_reset(ERROR_GROUP_OPEN_WIRE, 0U);
          break;
      case BMS_MANAGER_OPEN_WIRE:
          error_set(ERROR_GROUP_OPEN_WIRE, 0U);
          break;
      default:
          // Do nothing
          break;
  }
  /*** USER CODE END CHECK_OPEN_WIRE ***/
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

bms_monitor_fsm_state_t bms_monitor_fsm_run_state(bms_monitor_fsm_state_t cur_state, bms_monitor_fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN RUN_STATE ***/
  hfsm.fsm_state = cur_state;

  // TODO: Find a better way to handle read and write configuration operations
  // without exeucuting them immediately before or after the fsm status
  static bool rw = false;
  rw ? bms_manager_write_configuration() : bms_manager_read_configuration();
  rw = !rw;
  /*** USER CODE END RUN_STATE ***/

  bms_monitor_fsm_event_data_t *prev_ev = bms_monitor_fsm_fired_event;
  bms_monitor_fsm_state_t new_state = bms_monitor_fsm_state_table[cur_state](data);
  // Reset event status
  if (prev_ev != NULL)
    bms_monitor_fsm_fired_event = NULL;
  if (new_state == BMS_MONITOR_FSM_NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = bms_monitor_fsm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

/*** USER CODE BEGIN FUNCTIONS ***/
bms_monitor_fsm_state_t bms_monitor_fsm_get_state(void) {
    return hfsm.fsm_state;
}
/*** USER CODE END FUNCTIONS ***/

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  bms_monitor_fsm_state_t cur_state = BMS_MONITOR_FSM_STATE_INIT;
  do {
    cur_state = bms_monitor_fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (1);
  return 0;
}
#endif
