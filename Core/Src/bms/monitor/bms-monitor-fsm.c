/******************************************************************************
Finite State Machine
Project: cellboard_bms_monitor_fsm
Description: Cellboard FSM that handles all the operations of the BMS monitor

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.4
Generation date: 2024-08-25 19:03:09 +0000
Generated from: bms-monitor-fsm.dot
The finite state machine has:
  15 states
  2 transition functions
Functions and types have been generated with prefix "bms_monitor_fsm_"
******************************************************************************/

#include "bms-monitor-fsm.h"

/*** USER CODE BEGIN MACROS ***/
#include <stdint.h>
#include <string.h>

#include "timebase.h"
#include "error.h"
/*** USER CODE END MACROS ***/


// GLOBALS
// State human-readable names
const char *bms_monitor_fsm_state_names[] = {"init", "write_configuration", "read_configuration", "start_volt_conversion", "start_temp_conversion", "start_open_wire_pup_conversion", "poll_volt_status", "read_voltage", "poll_temp_status", "read_temperature", "poll_open_wire_pup_status", "read_open_wire_pup", "start_open_wire_pud_conversion", "poll_open_wire_pud_status", "read_open_wire_pud"};

// List of state functions
bms_monitor_fsm_state_func_t *const bms_monitor_fsm_state_table[BMS_MONITOR_FSM_NUM_STATES] = {
  bms_monitor_fsm_do_init,                           // in state init
  bms_monitor_fsm_do_write_configuration,            // in state write_configuration
  bms_monitor_fsm_do_read_configuration,             // in state read_configuration
  bms_monitor_fsm_do_start_volt_conversion,          // in state start_volt_conversion
  bms_monitor_fsm_do_start_temp_conversion,          // in state start_temp_conversion
  bms_monitor_fsm_do_start_open_wire_pup_conversion, // in state start_open_wire_pup_conversion
  bms_monitor_fsm_do_poll_volt_status,               // in state poll_volt_status
  bms_monitor_fsm_do_read_voltage,                   // in state read_voltage
  bms_monitor_fsm_do_poll_temp_status,               // in state poll_temp_status
  bms_monitor_fsm_do_read_temperature,               // in state read_temperature
  bms_monitor_fsm_do_poll_open_wire_pup_status,      // in state poll_open_wire_pup_status
  bms_monitor_fsm_do_read_open_wire_pup,             // in state read_open_wire_pup
  bms_monitor_fsm_do_start_open_wire_pud_conversion, // in state start_open_wire_pud_conversion
  bms_monitor_fsm_do_poll_open_wire_pud_status,      // in state poll_open_wire_pud_status
  bms_monitor_fsm_do_read_open_wire_pud,             // in state read_open_wire_pud
};

// Table of transition functions
transition_func_t *const bms_monitor_fsm_transition_table[BMS_MONITOR_FSM_NUM_STATES][BMS_MONITOR_FSM_NUM_STATES] = {
  /* states:                            init                                  , write_configuration                   , read_configuration                    , start_volt_conversion                 , start_temp_conversion                 , start_open_wire_pup_conversion        , poll_volt_status                      , read_voltage                          , poll_temp_status                      , read_temperature                      , poll_open_wire_pup_status             , read_open_wire_pup                    , start_open_wire_pud_conversion        , poll_open_wire_pud_status             , read_open_wire_pud                     */
  /* init                           */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* write_configuration            */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* read_configuration             */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* start_volt_conversion          */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* start_temp_conversion          */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* start_open_wire_pup_conversion */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* poll_volt_status               */ {NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* read_voltage                   */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* poll_temp_status               */ {NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* read_temperature               */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* poll_open_wire_pup_status      */ {NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  }, 
  /* read_open_wire_pup             */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* start_open_wire_pud_conversion */ {NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
  /* poll_open_wire_pud_status      */ {NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , bms_monitor_fsm_reset_poll_err_counter, NULL                                  , bms_monitor_fsm_reset_poll_err_counter}, 
  /* read_open_wire_pud             */ {NULL                                  , bms_monitor_fsm_check_open_wire       , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  , NULL                                  }, 
};

// Triggered event
bms_monitor_fsm_event_data_t * bms_monitor_fsm_fired_event = NULL;

/*** USER CODE BEGIN GLOBALS ***/
_STATIC _BmsMonitorFsmHandler hfsm;
/*** USER CODE END GLOBALS ***/


// Function to check if an event has fired
bool bms_monitor_fsm_is_event_triggered() {
    return bms_monitor_fsm_fired_event != NULL;
}

// Function to trigger an event
void bms_monitor_fsm_event_trigger(bms_monitor_fsm_event_data_t *event) {
    if (bms_monitor_fsm_fired_event != NULL)
        return;
    bms_monitor_fsm_fired_event = event ? event : &(bms_monitor_fsm_event_data_t){};
}


/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION
bms_monitor_fsm_state_t bms_monitor_fsm_do_init(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_INIT ***/
  memset(&hfsm, 0U, sizeof(hfsm));

  hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
  hfsm.temp_reg = BMS_MANAGER_TEMPERATURE_REGISTER_A;
  /*** USER CODE END DO_INIT ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state write_configuration
// valid return states: BMS_MONITOR_FSM_STATE_READ_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION, BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_write_configuration(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_READ_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_WRITE_CONFIGURATION ***/
  if (bms_manager_write_configuration() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_READ_CONFIGURATION;
  
  if (bms_monitor_fsm_is_event_triggered()) {
      if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_VOLTAGES)
          next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_TEMPERATURES)
          next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_START_OPEN_WIRE_CHECK)
          next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
  }
  /*** USER CODE END DO_WRITE_CONFIGURATION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_READ_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_configuration
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION, BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_configuration(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_READ_CONFIGURATION ***/
  if (bms_manager_read_configuration() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;

  if (bms_monitor_fsm_is_event_triggered()) {
      if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_VOLTAGES)
          next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_TEMPERATURES)
          next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_START_OPEN_WIRE_CHECK)
          next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
  }
  /*** USER CODE END DO_READ_CONFIGURATION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_volt_conversion
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_volt_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_START_VOLT_CONVERSION ***/
  if (bms_manager_start_volt_conversion() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS;
  else
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  /*** USER CODE END DO_START_VOLT_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_temp_conversion
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_temp_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_START_TEMP_CONVERSION ***/
  if (bms_manager_start_temp_conversion() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS;
  else
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  /*** USER CODE END DO_START_TEMP_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_open_wire_pup_conversion
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_open_wire_pup_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_START_OPEN_WIRE_PUP_CONVERSION ***/
  if (bms_manager_start_open_wire_conversion(LTC6811_PUP_ACTIVE) == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS;
  else
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  /*** USER CODE END DO_START_OPEN_WIRE_PUP_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_volt_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS, BMS_MONITOR_FSM_STATE_READ_VOLTAGE
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_volt_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE; 
  
  /*** USER CODE BEGIN DO_POLL_VOLT_STATUS ***/
  // TODO: After timeout go to write configuration 
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_VOLTAGE;
          break;
      case BMS_MANAGER_BUSY:
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
            next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }

  

  /*** USER CODE END DO_POLL_VOLT_STATUS ***/

  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_VOLTAGE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_voltage
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_VOLTAGE
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_voltage(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_VOLTAGE ***/
  BmsManagerReturnCode code = bms_manager_read_voltages(hfsm.volt_reg);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_OK:
          if (++hfsm.volt_reg >= BMS_MANAGER_VOLTAGE_REGISTER_COUNT) {
              hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_VOLTAGE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_VOLTAGE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_temp_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS, BMS_MONITOR_FSM_STATE_READ_TEMPERATURE
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_temp_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_TEMP_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_TEMPERATURE;
          break;
      case BMS_MANAGER_BUSY:
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
            next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }

  /*** USER CODE END DO_POLL_TEMP_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_TEMPERATURE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_temperature
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_TEMPERATURE
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_temperature(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_TEMPERATURE ***/
  BmsManagerReturnCode code = bms_manager_read_temperatures(hfsm.temp_reg);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_COMMUNICATION_ERROR:
      case BMS_MANAGER_ERROR:
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_OK:
          ++hfsm.temp_reg;
          if (hfsm.temp_reg >= BMS_MANAGER_TEMPERATURE_REGISTER_COUNT) {
              hfsm.temp_reg = BMS_MANAGER_TEMPERATURE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_READ_TEMPERATURE;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          hfsm.temp_reg = BMS_MANAGER_TEMPERATURE_REGISTER_A;
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_TEMPERATURE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_TEMPERATURE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_open_wire_pup_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_open_wire_pup_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_OPEN_WIRE_PUP_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          if (++hfsm.open_wire_operations >= BMS_MONITOR_FSM_OPEN_WIRE_PUP_CONVERSION_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP;
          }
          else
              next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION;
          break;
      case BMS_MANAGER_BUSY:
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
            next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          hfsm.open_wire_operations = 0U;
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }

  /*** USER CODE END DO_POLL_OPEN_WIRE_PUP_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUP_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUP_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_open_wire_pup
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_open_wire_pup(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_OPEN_WIRE_PUP ***/
  BmsManagerReturnCode code = bms_manager_read_open_wire_voltages(hfsm.volt_reg, BMS_MANAGER_OPEN_WIRE_OPERATION_PUP);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_OK:
          if (++hfsm.volt_reg >= BMS_MANAGER_VOLTAGE_REGISTER_COUNT) {
              hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE; 
          break;
      default:
          hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_OPEN_WIRE_PUP ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUP:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_open_wire_pud_conversion
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_open_wire_pud_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_START_OPEN_WIRE_PUD_CONVERSION ***/
  // TODO: Wait until end of conversion
  if (bms_manager_start_open_wire_conversion(LTC6811_PUP_INACTIVE) == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS;
  else
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  /*** USER CODE END DO_START_OPEN_WIRE_PUD_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_open_wire_pud_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION, BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_open_wire_pud_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_OPEN_WIRE_PUD_STATUS ***/
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          if (++hfsm.open_wire_operations >= BMS_MONITOR_FSM_OPEN_WIRE_PUD_CONVERSION_COUNT) {
              hfsm.open_wire_operations = 0U;
              next_state = BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD;
          }
          else
              next_state = BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION;
          break;
      case BMS_MANAGER_BUSY:
          if(++hfsm.poll_err_count >= FSM_MAX_POLL_ERR_COUNT) {
            next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          hfsm.open_wire_operations = 0U;
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }

  /*** USER CODE END DO_POLL_OPEN_WIRE_PUD_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_OPEN_WIRE_PUD_CONVERSION:
    case BMS_MONITOR_FSM_STATE_POLL_OPEN_WIRE_PUD_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_open_wire_pud
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_open_wire_pud(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_OPEN_WIRE_PUD ***/
  BmsManagerReturnCode code = bms_manager_read_open_wire_voltages(hfsm.volt_reg, BMS_MANAGER_OPEN_WIRE_OPERATION_PUD);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_OK:
          if (++hfsm.volt_reg >= BMS_MANAGER_VOLTAGE_REGISTER_COUNT) {
              hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE; 
          break;
      default:
          hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
          next_state = BMS_MONITOR_FSM_STATE_READ_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_OPEN_WIRE_PUD ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_OPEN_WIRE_PUD:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 10 transitions:
// 1. from poll_volt_status to write_configuration
// 2. from poll_volt_status to read_voltage
// 3. from poll_temp_status to write_configuration
// 4. from poll_temp_status to read_temperature
// 5. from poll_open_wire_pup_status to write_configuration
// 6. from poll_open_wire_pup_status to start_open_wire_pup_conversion
// 7. from poll_open_wire_pup_status to read_open_wire_pup
// 8. from poll_open_wire_pud_status to write_configuration
// 9. from poll_open_wire_pud_status to start_open_wire_pud_conversion
// 10. from poll_open_wire_pud_status to read_open_wire_pud
void bms_monitor_fsm_reset_poll_err_counter(bms_monitor_fsm_state_data_t *data) {
  /*** USER CODE BEGIN RESET_POLL_ERR_COUNTER ***/
  hfsm.poll_err_count = 0;
  /*** USER CODE END RESET_POLL_ERR_COUNTER ***/
}

// This function is called in 1 transition:
// 1. from read_open_wire_pud to write_configuration
void bms_monitor_fsm_check_open_wire(bms_monitor_fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN CHECK_OPEN_WIRE ***/
  BmsManagerReturnCode code = bms_manager_check_open_wire(); 
  switch (code) {
      case BMS_MANAGER_OK:
          error_reset(ERROR_GROUP_OPEN_WIRE, 0U);
          break;
      case BMS_MANAGER_OPEN_WIRE:
          error_set(ERROR_GROUP_OPEN_WIRE, 0U);
          break;
      default:
          // Do nothing
          break;
  }
  /*** USER CODE END CHECK_OPEN_WIRE ***/
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

bms_monitor_fsm_state_t bms_monitor_fsm_run_state(bms_monitor_fsm_state_t cur_state, bms_monitor_fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN RUN_STATE ***/
  hfsm.fsm_state = cur_state;
  /*** USER CODE END RUN_STATE ***/

  bms_monitor_fsm_event_data_t *prev_ev = bms_monitor_fsm_fired_event;
  bms_monitor_fsm_state_t new_state = bms_monitor_fsm_state_table[cur_state](data);
  // Reset event status
  if (prev_ev != NULL)
    bms_monitor_fsm_fired_event = NULL;
  if (new_state == BMS_MONITOR_FSM_NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = bms_monitor_fsm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

/*** USER CODE BEGIN FUNCTIONS ***/
bms_monitor_fsm_state_t bms_monitor_fsm_get_state(void) {
    return hfsm.fsm_state;
}
/*** USER CODE END FUNCTIONS ***/

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  bms_monitor_fsm_state_t cur_state = BMS_MONITOR_FSM_STATE_INIT;
  do {
    cur_state = bms_monitor_fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (1);
  return 0;
}
#endif
