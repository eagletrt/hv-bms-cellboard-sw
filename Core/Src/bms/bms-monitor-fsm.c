/******************************************************************************
Finite State Machine
Project: cellboard_bms_monitor_fsm
Description: Cellboard FSM that handles all the operations of the BMS monitor

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.4
Generation date: 2024-07-16 21:53:06 +0200
Generated from: bms-monitor-fsm.dot
The finite state machine has:
  9 states
  0 transition functions
Functions and types have been generated with prefix "bms_monitor_fsm_"
******************************************************************************/

#include "bms-monitor-fsm.h"

/*** USER CODE BEGIN MACROS ***/
#include <stdint.h>
#include <string.h>
/*** USER CODE END MACROS ***/


// GLOBALS
// State human-readable names
const char *bms_monitor_fsm_state_names[] = {"init", "write_configuration", "read_configuration", "start_volt_conversion", "start_temp_conversion", "poll_volt_status", "read_voltage", "poll_temp_status", "read_temperature"};

// List of state functions
bms_monitor_fsm_state_func_t *const bms_monitor_fsm_state_table[BMS_MONITOR_FSM_NUM_STATES] = {
  bms_monitor_fsm_do_init,                  // in state init
  bms_monitor_fsm_do_write_configuration,   // in state write_configuration
  bms_monitor_fsm_do_read_configuration,    // in state read_configuration
  bms_monitor_fsm_do_start_volt_conversion, // in state start_volt_conversion
  bms_monitor_fsm_do_start_temp_conversion, // in state start_temp_conversion
  bms_monitor_fsm_do_poll_volt_status,      // in state poll_volt_status
  bms_monitor_fsm_do_read_voltage,          // in state read_voltage
  bms_monitor_fsm_do_poll_temp_status,      // in state poll_temp_status
  bms_monitor_fsm_do_read_temperature,      // in state read_temperature
};
// No transition functions

// Triggered event
bms_monitor_fsm_event_data_t * bms_monitor_fsm_fired_event = NULL;

/*** USER CODE BEGIN GLOBALS ***/
_STATIC _BmsMonitorFsmHandler hfsm;
/*** USER CODE END GLOBALS ***/


// Function to check if an event has fired
bool bms_monitor_fsm_is_event_triggered() {
    return bms_monitor_fsm_fired_event != NULL;
}

// Function to trigger an event
void bms_monitor_fsm_event_trigger(bms_monitor_fsm_event_data_t *event) {
    if (bms_monitor_fsm_fired_event != NULL)
        return;
    bms_monitor_fsm_fired_event = event ? event : &(bms_monitor_fsm_event_data_t){};
}


/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION
bms_monitor_fsm_state_t bms_monitor_fsm_do_init(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_INIT ***/
  memset(&hfsm, 0U, sizeof(hfsm));

  hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
  hfsm.temp_reg = BMS_MANAGER_TEMPERATURE_REGISTER_A;
  /*** USER CODE END DO_INIT ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state write_configuration
// valid return states: BMS_MONITOR_FSM_STATE_READ_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION, BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_write_configuration(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_READ_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_WRITE_CONFIGURATION ***/
  if (bms_manager_write_configuration() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_READ_CONFIGURATION;
  
  if (bms_monitor_fsm_is_event_triggered()) {
      if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_VOLTAGES)
          next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_TEMPERATURES)
          next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
  }
  /*** USER CODE END DO_WRITE_CONFIGURATION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_READ_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_configuration
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION, BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_configuration(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_READ_CONFIGURATION ***/
  if (bms_manager_read_configuration() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;

  if (bms_monitor_fsm_is_event_triggered()) {
      if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_VOLTAGES)
          next_state = BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION;
      else if (bms_monitor_fsm_fired_event->type == BMS_MONITOR_FSM_EVENT_TYPE_READ_TEMPERATURES)
          next_state = BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION;
  }
  /*** USER CODE END DO_READ_CONFIGURATION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_START_VOLT_CONVERSION:
    case BMS_MONITOR_FSM_STATE_START_TEMP_CONVERSION:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_volt_conversion
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_volt_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_START_VOLT_CONVERSION ***/
  next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  if (bms_manager_start_volt_conversion() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS;
  /*** USER CODE END DO_START_VOLT_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_temp_conversion
// valid return states: BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS
bms_monitor_fsm_state_t bms_monitor_fsm_do_start_temp_conversion(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  
  
  /*** USER CODE BEGIN DO_START_TEMP_CONVERSION ***/
  next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
  if (bms_manager_start_temp_conversion() == BMS_MANAGER_OK)
      next_state = BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS;
  /*** USER CODE END DO_START_TEMP_CONVERSION ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_volt_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS, BMS_MONITOR_FSM_STATE_READ_VOLTAGE
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_volt_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_VOLT_STATUS ***/
  // TODO: After timeout go to write configuration
    
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_VOLTAGE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_POLL_VOLT_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_VOLT_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_VOLTAGE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_voltage
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_VOLTAGE
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_voltage(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_VOLTAGE ***/
  BmsManagerReturnCode code = bms_manager_read_voltages(hfsm.volt_reg);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_COMMUNICATION_ERROR:
      case BMS_MANAGER_ERROR:
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_OK:
          ++hfsm.volt_reg;
          if (hfsm.volt_reg >= BMS_MANAGER_VOLTAGE_REGISTER_COUNT) {
              hfsm.volt_reg = BMS_MANAGER_VOLTAGE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_READ_VOLTAGE;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_VOLTAGE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_VOLTAGE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state poll_temp_status
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS, BMS_MONITOR_FSM_STATE_READ_TEMPERATURE
bms_monitor_fsm_state_t bms_monitor_fsm_do_poll_temp_status(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_POLL_TEMP_STATUS ***/ 
  BmsManagerReturnCode code = bms_manager_poll_conversion_status();
  switch (code) {
      case BMS_MANAGER_OK:
          next_state = BMS_MONITOR_FSM_STATE_READ_TEMPERATURE;
          break;
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_POLL_TEMP_STATUS ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_POLL_TEMP_STATUS:
    case BMS_MONITOR_FSM_STATE_READ_TEMPERATURE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state read_temperature
// valid return states: BMS_MONITOR_FSM_NO_CHANGE, BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION, BMS_MONITOR_FSM_STATE_READ_TEMPERATURE
bms_monitor_fsm_state_t bms_monitor_fsm_do_read_temperature(bms_monitor_fsm_state_data_t *data) {
  bms_monitor_fsm_state_t next_state = BMS_MONITOR_FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_READ_TEMPERATURE ***/
  BmsManagerReturnCode code = bms_manager_read_temperatures(hfsm.temp_reg);
  // TODO: Timeout after multiple retries
  switch (code) {
      case BMS_MANAGER_COMMUNICATION_ERROR:
      case BMS_MANAGER_ERROR:
      case BMS_MANAGER_BUSY:
          next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      case BMS_MANAGER_OK:
          ++hfsm.temp_reg;
          if (hfsm.temp_reg >= BMS_MANAGER_TEMPERATURE_REGISTER_COUNT) {
              hfsm.temp_reg = BMS_MANAGER_TEMPERATURE_REGISTER_A;
              next_state = BMS_MONITOR_FSM_STATE_READ_TEMPERATURE;
          }
          else
              next_state = BMS_MONITOR_FSM_NO_CHANGE;
          break;
      default:
          next_state = BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION;
          break;
  }
  /*** USER CODE END DO_READ_TEMPERATURE ***/
  
  switch (next_state) {
    case BMS_MONITOR_FSM_NO_CHANGE:
    case BMS_MONITOR_FSM_STATE_WRITE_CONFIGURATION:
    case BMS_MONITOR_FSM_STATE_READ_TEMPERATURE:
      break;
    default:
      next_state = BMS_MONITOR_FSM_NO_CHANGE;
  }
  
  return next_state;
}



/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

bms_monitor_fsm_state_t bms_monitor_fsm_run_state(bms_monitor_fsm_state_t cur_state, bms_monitor_fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN RUN_STATE ***/
  
  /*** USER CODE END RUN_STATE ***/

  bms_monitor_fsm_event_data_t *prev_ev = bms_monitor_fsm_fired_event;
  bms_monitor_fsm_state_t new_state = bms_monitor_fsm_state_table[cur_state](data);
  // Reset event status
  if (prev_ev != NULL)
    bms_monitor_fsm_fired_event = NULL;
  if (new_state == BMS_MONITOR_FSM_NO_CHANGE) new_state = cur_state;
  return new_state;
};

/*** USER CODE BEGIN FUNCTIONS ***/

/*** USER CODE END FUNCTIONS ***/

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  bms_monitor_fsm_state_t cur_state = BMS_MONITOR_FSM_STATE_INIT;
  do {
    cur_state = bms_monitor_fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (1);
  return 0;
}
#endif
