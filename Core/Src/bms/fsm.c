/******************************************************************************
Finite State Machine
Project: cellboard_fsm
Description: Main cellboard FSM that handles all the operations of the BMS

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.5.2
Generation date: 2024-04-28 10:46:40 +0200
Generated from: fsm.dot
The finite state machine has:
  6 states
  7 transition functions
Functions and types have been generated with prefix "fsm_"
******************************************************************************/

#include "fsm.h"

/*** USER CODE BEGIN MACROS ***/

#include "post.h"
#include "timebase.h"
#include "identity.h"
#include "watchdog.h"

/*** USER CODE END MACROS ***/


// GLOBALS
// State human-readable names
const char *fsm_state_names[] = {"init", "idle", "fatal", "flash", "discharge", "cooldown"};

// List of state functions
state_func_t *const fsm_state_table[FSM_NUM_STATES] = {
  fsm_do_init,      // in state init
  fsm_do_idle,      // in state idle
  fsm_do_fatal,     // in state fatal
  fsm_do_flash,     // in state flash
  fsm_do_discharge, // in state discharge
  fsm_do_cooldown,  // in state cooldown
};

// Table of transition functions
transition_func_t *const fsm_transition_table[FSM_NUM_STATES][FSM_NUM_STATES] = {
  /* states:       init                     , idle                     , fatal                    , flash                    , discharge                , cooldown                  */
  /* init      */ {NULL                     , fsm_start                , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     }, 
  /* idle      */ {NULL                     , NULL                     , fsm_handle_fatal_error   , fsm_start_flash_procedure, fsm_start_discharge      , NULL                     }, 
  /* fatal     */ {NULL                     , NULL                     , NULL                     , fsm_start_flash_procedure, NULL                     , NULL                     }, 
  /* flash     */ {NULL                     , fsm_stop_flash_procedure , fsm_handle_fatal_error   , NULL                     , NULL                     , NULL                     }, 
  /* discharge */ {NULL                     , fsm_stop_discharge       , fsm_handle_fatal_error   , NULL                     , NULL                     , fsm_start_cooldown       }, 
  /* cooldown  */ {NULL                     , NULL                     , fsm_handle_fatal_error   , NULL                     , fsm_start_discharge      , NULL                     }, 
};

// Triggered event
fsm_event_data_t * fsm_fired_event = NULL;

/*** USER CODE BEGIN GLOBALS ***/

static fsm_state_t fsm_state = FSM_STATE_INIT;
static bms_cellboard_status_converted_t status_can_payload;

/*** USER CODE END GLOBALS ***/


// Function to check if an event has fired
inline bool fsm_is_event_triggered() {
    return fsm_fired_event != NULL;
}

// Function to trigger an event
inline void fsm_event_trigger(fsm_event_data_t *event) {
    if (fsm_fired_event != NULL)
        return;
    fsm_fired_event = event ? event : &(fsm_event_data_t){};
}


/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
// valid return states: FSM_STATE_IDLE, FSM_STATE_FATAL
fsm_state_t fsm_do_init(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_STATE_IDLE;
  
  
  /*** USER CODE BEGIN DO_INIT ***/
  // Run POST and verify that everything is working
  PostInitData * post_data = (PostInitData *)data;
  PostReturnCode status = post_run(*post_data);
  switch (status) {
      case POST_OK:
          next_state = FSM_STATE_IDLE;
          break;

      default:
          next_state = FSM_STATE_FATAL;
          break;
  }
  // TODO: Enable timebase and can_comm in transition from init to fatal?

  status_can_payload.cellboard_id = identity_get_cellboard_id();
  /*** USER CODE END DO_INIT ***/
  
  switch (next_state) {
    case FSM_STATE_IDLE:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_DISCHARGE, FSM_STATE_FATAL
fsm_state_t fsm_do_idle(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_IDLE ***/

  (void)timebase_routine();
  (void)led_routine(timebase_get_time());

  /*** USER CODE END DO_IDLE ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_FLASH:
    case FSM_STATE_DISCHARGE:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state fatal
// valid return states: FSM_NO_CHANGE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_fatal(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_FATAL ***/

  (void)timebase_routine();
  
  /*** USER CODE END DO_FATAL ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_FLASH:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flash
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_FLASH, FSM_STATE_FATAL
fsm_state_t fsm_do_flash(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_FLASH ***/
  
  /*** USER CODE END DO_FLASH ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_FLASH:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state discharge
// valid return states: FSM_NO_CHANGE, FSM_STATE_IDLE, FSM_STATE_DISCHARGE, FSM_STATE_COOLDOWN, FSM_STATE_FATAL
fsm_state_t fsm_do_discharge(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_DISCHARGE ***/

  (void)timebase_routine();

  /*** USER CODE END DO_DISCHARGE ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_IDLE:
    case FSM_STATE_DISCHARGE:
    case FSM_STATE_COOLDOWN:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state cooldown
// valid return states: FSM_NO_CHANGE, FSM_STATE_DISCHARGE, FSM_STATE_COOLDOWN, FSM_STATE_FATAL
fsm_state_t fsm_do_cooldown(fsm_state_data_t *data) {
  fsm_state_t next_state = FSM_NO_CHANGE;
  
  
  /*** USER CODE BEGIN DO_COOLDOWN ***/
  
  (void)timebase_routine();

  /*** USER CODE END DO_COOLDOWN ***/
  
  switch (next_state) {
    case FSM_NO_CHANGE:
    case FSM_STATE_DISCHARGE:
    case FSM_STATE_COOLDOWN:
    case FSM_STATE_FATAL:
      break;
    default:
      next_state = FSM_NO_CHANGE;
  }
  
  return next_state;
}


/*  _____                    _ _   _              
 * |_   _| __ __ _ _ __  ___(_) |_(_) ___  _ __   
 *   | || '__/ _` | '_ \/ __| | __| |/ _ \| '_ \
 *   | || | | (_| | | | \__ \ | |_| | (_) | | | | 
 *   |_||_|  \__,_|_| |_|___/_|\__|_|\___/|_| |_| 
 *                                                
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */    
                                         
// This function is called in 1 transition:
// 1. from init to idle
void fsm_start(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START ***/
  // Enable timebase, CAN communication and watchdogs
  can_comm_set_enable(true); 
  timebase_set_enable(true);
  led_set_enable(true);
  watchdog_start_all();
  /*** USER CODE END START ***/
}

// This function is called in 5 transitions:
// 1. from init to fatal
// 2. from idle to fatal
// 3. from flash to fatal
// 4. from discharge to fatal
// 5. from cooldown to fatal
void fsm_handle_fatal_error(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN HANDLE_FATAL_ERROR ***/
  
  /*** USER CODE END HANDLE_FATAL_ERROR ***/
}

// This function is called in 2 transitions:
// 1. from idle to flash
// 2. from fatal to flash
void fsm_start_flash_procedure(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_FLASH_PROCEDURE ***/

  timebase_set_enable(false);
  
  /*** USER CODE END START_FLASH_PROCEDURE ***/
}

// This function is called in 2 transitions:
// 1. from idle to discharge
// 2. from cooldown to discharge
void fsm_start_discharge(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_DISCHARGE ***/
  
  /*** USER CODE END START_DISCHARGE ***/
}

// This function is called in 1 transition:
// 1. from flash to idle
void fsm_stop_flash_procedure(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN STOP_FLASH_PROCEDURE ***/

  timebase_set_enable(true);
  
  /*** USER CODE END STOP_FLASH_PROCEDURE ***/
}

// This function is called in 1 transition:
// 1. from discharge to idle
void fsm_stop_discharge(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN STOP_DISCHARGE ***/
  
  /*** USER CODE END STOP_DISCHARGE ***/
}

// This function is called in 1 transition:
// 1. from discharge to cooldown
void fsm_start_cooldown(fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN START_COOLDOWN ***/
  
  /*** USER CODE END START_COOLDOWN ***/
}


/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

fsm_state_t fsm_run_state(fsm_state_t cur_state, fsm_state_data_t *data) {
  
  /*** USER CODE BEGIN RUN_STATE ***/
  fsm_state = cur_state; 
  /*** USER CODE END RUN_STATE ***/

  fsm_event_data_t *prev_ev = fsm_fired_event;
  fsm_state_t new_state = fsm_state_table[cur_state](data);
  // Reset event status
  if (prev_ev != NULL)
    fsm_fired_event = NULL;
  if (new_state == FSM_NO_CHANGE) new_state = cur_state;
  transition_func_t *transition = fsm_transition_table[cur_state][new_state];
  if (transition)
    transition(data);
  return new_state;
};

/*** USER CODE BEGIN FUNCTIONS ***/

fsm_state_t fsm_get_status(void) {
    return fsm_state;
}

bms_cellboard_status_converted_t * fsm_get_can_payload(size_t * byte_size) {
    if (byte_size != NULL)
        *byte_size = sizeof(status_can_payload);

    // Cellboard id is saved during init
    fms_status_can_payload.status = fsm_state;
    return &status_can_payload;
}

/*** USER CODE END FUNCTIONS ***/

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  fsm_state_t cur_state = FSM_STATE_INIT;
  do {
    cur_state = fsm_run_state(cur_state, NULL);
    sleep(1);
  } while (1);
  return 0;
}
#endif
