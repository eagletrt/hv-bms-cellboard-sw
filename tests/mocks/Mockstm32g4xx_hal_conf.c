/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockstm32g4xx_hal_conf.h"

static const char* CMockString_assert_failed = "assert_failed";
static const char* CMockString_file = "file";
static const char* CMockString_line = "line";

typedef struct _CMOCK_assert_failed_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t* Expected_file;
  uint32_t Expected_line;

} CMOCK_assert_failed_CALL_INSTANCE;

static struct Mockstm32g4xx_hal_confInstance
{
  char assert_failed_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE assert_failed_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mockstm32g4xx_hal_conf_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.assert_failed_CallInstance;
  if (Mock.assert_failed_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_assert_failed);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockstm32g4xx_hal_conf_Init(void)
{
  Mockstm32g4xx_hal_conf_Destroy();
}

void Mockstm32g4xx_hal_conf_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

void assert_failed(uint8_t* file, uint32_t line)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_assert_failed_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_assert_failed);
  cmock_call_instance = (CMOCK_assert_failed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.assert_failed_CallInstance);
  Mock.assert_failed_CallInstance = CMock_Guts_MemNext(Mock.assert_failed_CallInstance);
  if (Mock.assert_failed_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_assert_failed,CMockString_file);
    if (cmock_call_instance->Expected_file == NULL)
      { UNITY_TEST_ASSERT_NULL(file, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_file, file, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_assert_failed,CMockString_line);
    UNITY_TEST_ASSERT_EQUAL_HEX32(cmock_call_instance->Expected_line, line, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_assert_failed(CMOCK_assert_failed_CALL_INSTANCE* cmock_call_instance, uint8_t* file, uint32_t line);
void CMockExpectParameters_assert_failed(CMOCK_assert_failed_CALL_INSTANCE* cmock_call_instance, uint8_t* file, uint32_t line)
{
  cmock_call_instance->Expected_file = file;
  cmock_call_instance->Expected_line = line;
}

void assert_failed_CMockIgnore(void)
{
  Mock.assert_failed_IgnoreBool = (char)1;
}

void assert_failed_CMockStopIgnore(void)
{
  Mock.assert_failed_IgnoreBool = (char)0;
}

void assert_failed_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t* file, uint32_t line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_assert_failed_CALL_INSTANCE));
  CMOCK_assert_failed_CALL_INSTANCE* cmock_call_instance = (CMOCK_assert_failed_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.assert_failed_CallInstance = CMock_Guts_MemChain(Mock.assert_failed_CallInstance, cmock_guts_index);
  Mock.assert_failed_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_assert_failed(cmock_call_instance, file, line);
}

